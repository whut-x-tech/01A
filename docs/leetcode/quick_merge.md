#  **快速排序** 和 **归并排序** 

---

## 一、快速排序模板
### 代码模板
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6+10;
int q[N];

void quick_sort(int q[], int l, int r) {
    if (l >= r) return;  // 终止条件：区间长度为0或1

    int i = l - 1, j = r + 1;  // 初始化双指针（扩大范围）
    int x = q[l + r >> 1];      // 选取中间元素为基准值

    while (i < j) {
        do i++; while (q[i] < x);  // 找左边第一个≥x的元素
        do j--; while (q[j] > x);  // 找右边第一个≤x的元素
        if (i < j) swap(q[i], q[j]); // 交换不符合条件的元素
    }

    quick_sort(q, l, j);     // 递归处理左半区间
    quick_sort(q, j + 1, r); // 递归处理右半区间
}

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%d", &q[i]);
    quick_sort(q, 0, n - 1);
    for (int i = 0; i < n; i++) printf("%d ", q[i]);
    return 0;
}
```

---

### 关键步骤解析
1. **基准选择**：  
   - 选择中间元素 `x = q[l + r >> 1]`（位运算等价于 `(l + r) / 2`）。
   - 目的是避免极端分布（如已排序数组）导致性能退化。

2. **双指针分区**：  
   - `i` 向右扫描，找到第一个 **≥x** 的元素；  
   - `j` 向左扫描，找到第一个 **≤x** 的元素；  
   - 若 `i < j` 则交换，确保左半区间的元素 **≤x**，右半区间的元素 **≥x**。

3. **递归分治**：  
   - 分界点为 `j`，左区间 `[l, j]` 和右区间 `[j+1, r]`。

---

### 注意事项
1. **边界问题**：  
   - 必须初始化 `i = l-1` 和 `j = r+1`，确保先移动再比较。
   - 递归时区间必须分割为 `[l, j]` 和 `[j+1, r]`，不可用 `i` 分界。

2. **时间复杂度**：  
   - 平均：\(O(n \log n)\)  
   - 最坏：\(O(n^2)\)（但合理选择基准可避免）

---

## 二、归并排序模板
### 代码模板
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
int q[N], tmp[N]; // 需要额外临时数组

void merge_sort(int q[], int l, int r) {
    if (l >= r) return;  // 终止条件：区间长度为0或1

    int mid = l + r >> 1;       // 计算中间点
    merge_sort(q, l, mid);      // 递归左半区间
    merge_sort(q, mid + 1, r);  // 递归右半区间

    // 合并两个有序数组
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r) {
        if (q[i] <= q[j]) tmp[k++] = q[i++];
        else tmp[k++] = q[j++];
    }

    // 处理剩余元素
    while (i <= mid) tmp[k++] = q[i++];
    while (j <= r) tmp[k++] = q[j++];

    // 将合并结果拷贝回原数组
    for (i = l, j = 0; i <= r; i++, j++) q[i] = tmp[j];
}

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%d", &q[i]);
    merge_sort(q, 0, n - 1);
    for (int i = 0; i < n; i++) printf("%d ", q[i]);
    return 0;
}
```

---

### 关键步骤解析
1. **递归分治**：  
   - 将数组分成两半，分别递归排序。

2. **合并有序数组**：  
   - 使用双指针 `i` 和 `j` 遍历左右两半，按顺序将元素填入临时数组 `tmp`。

3. **处理剩余元素**：  
   - 将左半或右半未遍历完的元素直接追加到 `tmp`。

4. **拷贝回原数组**：  
   - 将 `tmp` 中的合并结果覆盖到原数组对应区间。

---

### 注意事项
1. **空间复杂度**：  
   - 需要额外 \(O(n)\) 空间的临时数组 `tmp`。

2. **时间复杂度**：  
   - 稳定为 \(O(n \log n)\)。

3. **稳定性**：  
   - 归并排序是稳定排序（`if (q[i] <= q[j])` 中的 `<=` 保证了稳定性）。

---

## 三、快速排序 vs 归并排序
| 特性           | 快速排序               | 归并排序               |
| -------------- | ---------------------- | ---------------------- |
| **时间复杂度** | 平均 \(O(n \log n)\)   | 稳定 \(O(n \log n)\)   |
| **空间复杂度** | 递归栈 \(O(\log n)\)   | 额外数组 \(O(n)\)      |
| **稳定性**     | 不稳定                 | 稳定                   |
| **适用场景**   | 内存敏感、无需稳定排序 | 需要稳定排序或链表排序 |
| **核心操作**   | 原地分区               | 合并有序数组           |

---

## 四、常见问题
1. **快速排序死循环**：  
   - 若用 `i` 分界且基准选 `q[r]`，当所有元素相等时会导致死循环。必须用 `j` 分界。

2. **归并排序越界**：  
   - 确保临时数组 `tmp` 的大小足够（与 `q` 数组一致）。

3. **性能对比**：  
   - 快速排序常数更小，实际运行更快；归并排序稳定但需要额外空间。

<Artalk />